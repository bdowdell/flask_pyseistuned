{% extends 'base.html' %}
{% block head %}
    {{ super() }}
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <!-- custom CSS -->
    <link rel="stylesheet" href="../static/css/style.css" />
{% endblock %}

{% block content %}
    <h1>{% block title %} About {% endblock %}</h1>
    <p class="text-justify">
        <strong>PySeisTuned<sup>2.0</sup></strong> is a tool for calculating seismic tuning wedges. Input the velocity
        and density properties of the wedge layers, specify the wavelet parameters, and a synthetic tuning wedge and
        tuning curve are generated.
    </p>
    <p class="text-justify">
        The initial release, <strong>PySeisTuned<sup>1.0</sup></strong>, was inspired by Agile Scientific's
        <a href="https://github.com/agile-geoscience/xlines/blob/master/notebooks/00_Synthetic_wedge_model.ipynb"
           target="_blank">"X Lines of Code"</a> Jupyter Notebook series and was written as a standalone GUI using
        Python 3 and PyQT5. In this iteration, a user needs to create a virtual conda environment using the provided
        environment.yml file and then launch the app from a command line prompt. While this works, it probably isn't
        the most user-friendly deployment. PySeisTuned<sup>1.0</sup> is open source and licensed under GPL-3.0 for
        compatibility with PyQT5 licensing.
    </p>
    <div class="row row-cols-2">
        <div class="col-sm">
            <figure class="figure">
                <img src="../static/img/pst_wedge_calculator.png" class="figure-img img-fluid rounded" alt="" loading="lazy">
                <figcaption class="figure-caption">PySeisTuned<sup>1.0</sup> Inputs tab</figcaption>
            </figure>
        </div>
        <div class="col-sm">
            <figure class="figure">
                <img src="../static/img/pst_summary_tab.png" class="figure-img img-fluid rounded" alt="" loading="lazy">
                <figcaption class="figure-caption">PySeisTuned<sup>1.0</sup> Summary tab</figcaption>
            </figure>
        </div>
    </div>
    <p class="text-justify">
        Enter <strong>PySeisTuned<sup>2.0</sup></strong>, which is now a web app! The PyQT5 GUI is gone and now
        PySeisTuned<sup>2.0</sup> runs using Python 3, Flask, HTML5, Bootstrap, & JavaScript. PySeisTuned<sup>2.0</sup>
        is open source and licensed under the Apache-2.0 license. My primary goal in re-writing PySeisTuned<sup>2.0</sup>
        as a web app is to make the tool as easy as possible to use. Web apps have changed the way we interact with software
        and simplifies end-user consumption. To me, this means removing the environmental setup
        steps necessary to run PySeisTuned<sup>1.0</sup> and also removing the need to launch from a terminal. In fact,
        unless you want to clone the repository locally to customize PySeisTuned<sup>2.0</sup>, there is no longer any
        "installation" steps required to get running!
    </p>
    <p class="text-justify">
        Flask is a powerful and easy to use Python-based web app framework that connects the Python code in the
        background with the HTML5 user-interface.  Styling is made simple by utilizing Bootstrap pre-built CSS style
        sheets. Additionally, some custom JavaScript is required to enable features such as a reset button, displaying
        Acoustic Impedance of input layer properties, and displaying the apparent frequency of the specified Ricker
        wavelet. One more enhancement is that all plotting is now done using Bokeh instead of Matplotlib. Using Bokeh
        enables embedding feature-rich, interactive plots that are more appropriate in a web app.
    </p>
    <div class="container">
        <div class="row row-cols-8">
            <div class="col-sm"></div>
            <div class="col-sm">
                <a href="https://www.python.org" target="_blank">
                    <img src="https://img.icons8.com/color/48/000000/python.png" class="img-fluid" alt="" loading="lazy"/>
                </a>
            </div>
            <div class="col-sm">
                <a href="https://docs.bokeh.org/en/latest/index.html#" target="_blank">
                    <img src="../static/img/bokeh-logo.png" width="48" height="48" class="img-fluid" alt="" loading="lazy"/>
                </a>
            </div>
            <div class="col-sm">
                <a href="https://flask.palletsprojects.com/en/1.1.x/" target="_blank">
                    <img src="../static/img/flask-logo.png" width="96" height="96" class="img-fluid" alt="" loading="lazy"/>
                </a>
            </div>
            <div class="col-sm">
                <a href="https://www.w3.org/html/" target="_blank">
                    <img src="https://img.icons8.com/color/48/000000/html-5.png" class="img-fluid" alt="" loading="lazy"/>
                </a>
            </div>
            <div class="col-sm">
                <a href="https://getbootstrap.com/" target="_blank">
                    <img src="https://img.icons8.com/color/48/000000/bootstrap.png" class="img-fluid" alt="" loading="lazy"/>
                </a>
            </div>
            <div class="col-sm">
                <a href="https://www.javascript.com/" target="_blank">
                    <img src="https://img.icons8.com/color/48/000000/javascript.png" class="img-fluid" alt="" loading="lazy"/>
                </a>
            </div>
            <div class="col-sm"></div>
        </div>
    </div>
    <br />
    <p class="text-justify">
        Contributions, suggestions, and bug reports are all welcome! I hope you enjoy using
        <strong>PySeisTuned<sup>2.0</sup></strong> and please let me know if there ways I can make it even better:
    </p>
    <p class="text-justify">
        Follow the links below to view the source code, clone the repository, or submit issues and enhancement requests:
    </p>
    <ul class="no_bullet">
        <li class="wiggle">
            <a href="https://github.com/bdowdell/flask_pyseistuned" target="_blank">PySeisTuned<sup>2.0</sup></a>
        </li>
        <li class="wiggle">
            <a href="https://github.com/bdowdell/PySeisTuned" target="_blank">PySeisTuned<sup>1.0</sup></a>
        </li>
    </ul>
    <br />
    <p class="text-justify">
        You can also send an email directly using the <em>Contact</em> link down below in the footer.
    </p>
    <!-- Introduce a horizontal break to begin a cursory background theory section -->
    <hr />
    <h1>Seismic Tuning Theory Basics</h1>
    <p class="text-justify">
        Seismic Tuning as a concept is a basic geophysical tenet and is crucial in understanding the seismic
        response. The seismic tuning phenomenon arises from constructive interference of reflected waves at layer
        interfaces as the bed thickness between the layer begins to thin. As the bed begins to thin, the reflection from
        the top interface and the bottom interface begin to align and constructively interfere. At a certain point, the
        constructive interference between the two layers will reach a maximum and this is known as the
        <strong>Seismic Tuning Thickness</strong> and is the layer thickness below which the top and base reflections
        are no longer indistinguishable from one another.
    </p>
    <p class="text-justify">
        <a href="https://doi.org/10.1190/1.1440403" target="_blank">Widess (1973)</a>
        published the seminal work on the topic titled <em>"How thin is a thin bed?"</em>, which sought to
        dispel common misconceptions about thin bed resolvability. In the paper, Widess considers two identical wavelets
        offset by a time delay. The two wavelets effectively represent the reflections from the top and base of a layer
        while the time delay effectively represents the bed thickness in Two-Way Time (TWT). Several very important
        definitions arise from Widess's paper:
    </p>
    <dl class="row">
        <dt class="col-sm-3">Onset of Tuning Thickness</dt>
        <dd class="col-sm-9">\(\lambda/2\)</dd>
        <dt class="col-sm-3">Tuning Thickness</dt>
        <dd class="col-sm-9">\(\lambda/4\)</dd>
        <dt class="col-sm-3">Limit of resolution</dt>
        <dd class="col-sm-9">\(\lambda/8\)</dd>
    </dl>
    <p class="text-justify">
        where \(\lambda\) is the velocity-dependent wavelength of the layer's dominant frequency.  Recall the relationship
        between velocity, frequency, and wavelength:
    </p>
    <p>
        $$v = f \times \lambda$$
    </p>
    <p class="text-justify">
        where \(v\) is velocity in (m or ft)/sec, \(f\) is Frequency in Hz (or cycles/sec), and \(\lambda\) is
        wavelength in (m or ft). This equation commonly gets rewritten as:
    </p>
    <p>
        $$\lambda = {v\over f}$$
    </p>
    <p class="text-justify">
        because we typically have an idea about what the velocity and frequency of our zone of interest is and instead
        want to know wavelength. Once we know the dominant frequency wavelength we can then estimate the tuning
        parameters using Widess's definitions above. For example, the tuning thickness is given by:
    </p>
    <p>
        $$\lambda_{tuning} = {v\over f}/4$$
    </p>
    <p class="text-justify">
        We can also define the tuning parameters in terms of TWT thickness.  If we take the inverse of frequency, we
        instead get the TWT period, \(T\) in seconds. The equation above can now be
        written as:
    </p>
    <p>
        $$\lambda = v\times T/2$$
    </p>
    <p class="text-justify">
        with the period \(T\) being divided by two to convert to One-Way Time (OWT).
        Converting the period to OWT is essential as otherwise the depth thickness we measure would be twice the actual
        bed thickness. This means that when the Widess tuning parameters are expressed in terms of TWT, the divisor
        becomes half the wavelength divisor so that when the TWT tuning parameter is converted to OWT, the overall
        relationship remains the same:
    </p>
    <dl class="row">
        <dt class="col-sm-3">Onset of Tuning Thickness</dt>
        <dd class="col-sm-9">\(\lambda/2 = T\)</dd>
        <dt class="col-sm-3">Tuning Thickness</dt>
        <dd class="col-sm-9">\(\lambda/4 = T/2\)</dd>
        <dt class="col-sm-3">Limit of resolution</dt>
        <dd class="col-sm-9">\(\lambda/8 = T/4\)</dd>
    </dl>
    <p class="text-justify">
        such that the tuning parameter thicknesses are given by:
    </p>
    <p>
        \begin{align}
        &\lambda_{onset} = v\times T/2 \\
        &\lambda_{tuning} = v\times (T/2)/2 \\
        &\lambda_{limit} = v\times (T/4)/2
        \end{align}
    </p>
    <p class="text-justify">
        The advantage to expressing the various tuning parameters in TWT versus depth units is that doing so only
        requires knowledge of the layer's dominant frequency and as such, TWT tuning thickness is always constant for
        a given frequency.  In other words, if the apparent frequency of a particular reflection pair is 25 Hz,
        then the TWT tuning thickness is simply:
    </p>
    <p>
        \begin{align}
        T_{tuning} & = 1/f/2 \\
        & = 1/25\;Hz/2 \\
        & = 20\;ms\;TWT\;,
        \end{align}
    </p>
    <p class="text-justify">
        and if we know that the velocity of the layer, either from well log control or a seismic velocity model, is
        3,000 m/s, then the tuning thickness in meters is:
    </p>
    <p>
        \begin{align}
        \lambda_{tuning} & = v\times (T/2)/2 \\
        & = 3000\;m/s\times 20\;ms\;TWT/2 \\
        & = 3000\;m/s\times 0.020\;s\;TWT/2 \\
        & = 30\;m
        \end{align}
    </p>
    <hr />
    <h1>Seismic Tuning Wedge Model</h1>
    <p class="text-justify">
        Now that the foundational concepts behind seismic tuning are laid out, we can now understand the utility of
        the <strong>Seismic Tuning Wedge Model</strong>. The seismic tuning wedge model is a simple three-layer forward
        model in which the top and base layers are typically the same and the middle wedge layer simulates the layer of
        interest. In other words, the top and base layers usually represent the encasing shale and the wedge layer
        represents a sandstone. The wedge layer is typically given a maximum thickness well above tuning at one end of
        the model and thins out to zero thickness at the other. The thicknesses of the top and base layers are not
        important as we only care about the reflections generated at the wedge top and base interfaces.
    </p>
    <figure class="figure">
        <img src="../static/img/wedge.png" class="figure-img img-fluid rounded mx-auto d-block" alt="Wedge Model" loading="lazy">
        <figcaption class="figure-caption">
            An example of a wedge model with the layers colored by Acoustic Impedance, \(AI\). The model has three
            layers, with the top and bottom layer having the same \(AI\).  The second layer, which is the wedge, has
            a maximum thickness on one side and thins to zero thickness at the other.
        </figcaption>
    </figure>
    <p class="text-justify">
        For a very simple wedge model, it is only necessary to know the P-velocity, \(V_p\), and bulk density, \(\rho\),
        of the three layers. Generally, and as implemented in <strong>PySeisTuned<sup>2.0</sup></strong>,
        the properties of the top and base layers are the same. More detailed forward models can be built to understand
        reflectivity from differing top and base properties, but if the goal is simply to understand seismic resolution
        of a sand body, then in my opinion it is best to keep the top and base properties the same. The underlying
        assumption is that the encasing shales do not have drastically varying properties, but that is not always the
        case.
    </p>
    <p class="text-justify">
        Once \(V_p\) - \(\rho\) pairs are assigned at each sample, the Acoustic Impedance, \(AI = V_p\times\rho\),
        (also sometimes denoted as \(Z_p\))
        of each layer is calculated. In a simple wedge model, \(AI\) does not vary laterally or vertically within a
        given layer. In order to have a seismic reflection generated at a layer boundary, there must be a contrast in
        \(AI\) across the interface. The reflectivity of a layer interface at normal incidence is called the
        <strong>Reflection Coefficient</strong>:
    </p>
    <p>
        $$RC = \frac{AI_2 - AI_1}{AI_2 + AI_1}$$
    </p>
    <p class="text-justify">
        If there is no contrast in \(AI\) at the interface of two layers, no seismic reflection is generated
        (\(RC = 0\)) and the layer below the interface is deemed to be acoustically invisible, assuming that the lower
        layer is sufficiently thick to be seismically resolvable otherwise. This assumption is why half-space models,
        which consider the layers above and below an interface to be infinitely thick, are only useful for
        understanding reflectivity at an interface. Wedge models allow us to understand how thickness impacts
        reflectivity, as well!
    </p>
    <p class="text-justify">
        Calculating the \(RC\) of the wedge model results in an impulse response at the top and
        base of the wedge and zero values everywhere else. Once the reflection coefficients are calculated, the model
        can be convolved with a wavelet to produce a wedge model with a synthetic trace for each thickness step. For
        example, here is the \(AI\), \(RC\), and synthetic trace for a blocky model with the following properties:
    </p>
    <dl class="row">
        <dt class="col-sm-3">Top & Base Layer</dt>
        <dd class="col-sm-9">\(V_p = 3,000\;m/s\;,\rho = 2.5\;g/cm^3\)</dd>
        <dt class="col-sm-3">Wedge Layer</dt>
        <dd class="col-sm-9">\(V_p = 2,700\;m/s\;,\rho = 2.3\;g/cm^3\)</dd>
        <dt class="col-sm-3">Ricker Wavelet</dt>
        <dd class="col-sm-9">\(F_{central} = 32\;Hz\;,duration = 0.100\;sec\;,dt = 0.001\;sec\)</dd>
    </dl>
    <figure class="figure">
        <img src="../static/img/layerAI_rc_synth.png" class="figure-img img-fluid rounded mx-auto d-block" alt="" loading="lazy">
        <figcaption class="figure-caption">
            This figure illustrates the relationship between Acoustic Impedance, \(AI\), Reflection Coefficient, \(RC\),
            and the synthetic seismic trace. This simple blocky model is extracted from a wedge model at the point
            where the wedge thickness is 80 ms TWT. The \(AI\) of the middle layer decreases relative to the layers
            above and below. This results in a negative \(RC\) at the top interface of the layer and a positive \(RC\)
            at the bottom interface. When a \(RC\) series is convolved with a wavelet, the result is a seismic trace.
        </figcaption>
    </figure>
    <p class="text-justify">
        This raises an important point about polarity conventions. <strong>PySeisTuned<sup>2.0</sup></strong> adopts
        <strong>SEG Normal Polarity</strong>, meaning that a decrease in \(AI\) results in a negative reflection
        coefficient, or a trough in the seismic response. Additionally, a decrease in impedance is represented by red
        while an increase is represented by blue. While this seems simple, understanding the polarity convention of a
        seismic dataset is fundamental to successful interpretation.
    </p>
    <p class="text-justify">
        We can now look at a wedge model which extends the blocky impedance model above. Using the properties for the
        layers as defined above but varying thickness of the middle wedge layer from 0 to 100 ms TWT results creates
        the following wedge model:
    </p>
    <figure class="figure">
        <img src="../static/img/wedge_model_w_blocky_impedance.png" class="figure-img img-fluid rounded mx-auto d-block" alt="blocky wedge model" loading="lazy">
        <figcaption class="figure-caption">
            Wedge model showing blocky acoustic impedance for every fifth trace. The layer impedances are rendered in
            transparent color.
        </figcaption>
    </figure>
    <p class="text-justify">
        Next, the \(RC\) at the top and base wedge interfaces are calculated and then convolved with the same Ricker
        wavelet with \(F_{central} = 32\;Hz\) to create the synthetic seismic wedge model:
    </p>
    <figure class="figure">
        <img src="../static/img/synthetic_wedge_model.png" class="figure-img img-fluid rounded mx-auto d-block" alt="synthetic wedge model" loading="lazy">
        <figcaption class="figure-caption">
            Synthetic seismic wedge model resulting from convolving the reflectivities of the \(AI\) wedge model with a
            \(F_{central} = 32\;Hz\) Ricker wavelet. Every fifth trace is plotted along with the interpolated density.
        </figcaption>
    </figure>
    <p class="text-justify">
        Cool! So now we have synthetic wedge model, but now what? What does this tell us and why do we care about what
        all we just went through? If we extract the amplitude across the top of the wedge, we can create a plot called
        the <em>Tuning Curve</em>, shown below:
    </p>
    <figure class="figure">
        <img src="../static/img/tuning_curve.png" class="figure-img img-fluid rounded mx-auto d-block" alt="tuning curve" loading="lazy">
        <figcaption class="figure-caption">
            Tuning curve (left) extracted along the top of the wedge at the interface of layers 1 and 2, and a plot
            (right) of true versus apparent wedge thickness.
        </figcaption>
    </figure>
    <p class="text-justify">
        From the tuning curve we can quickly make observations about how layer thickness impacts relfection amplitude.
        First, when the wedge is much thicker than tuning thickness, the amplitude at the top interface is unaffected.
        Once the wedge thins to a thickness of \(\lambda/2\) or \(T\), we see that the tuning curve begins to turn
        upwards as the reflections from the top and base of the wedge begin to constructively interfere. Continuing to
        thin the wedge results in stronger constructive interference until thinned to a thickness of \(\lambda/4\) or
        \(T/2\) at which point constructive interference reaches a maximum. This is the <em>Tuning</em> thickness and
        is the thinnest a layer can be and still seismically resolve a layer's top and base.
        Thinning the wedge beyond tuning will then result in destructive interference between the top and base wedge
        reflections and the tuning curve decreases in amplitude rapidly. If a layer is thinner than the tuning
        thickness, the top and base reflections can no longer be fully resolved and the layer thickness cannot be
        directly estimated from seismic mapping. More on this in a moment ...
    </p>
    <p class="text-justify">
        Let's take another look at the interpolated density and wiggle trace plot of the synthetic wedge model:
    </p>
    <figure class="figure">
        <img src="../static/img/synthetic_wedge_model_extra.png" class="figure-img img-fluid rounded mx-auto d-block" alt="synthetic wedge" loading="lazy">
        <figcaption class="figure-caption">
            Interpolated density and wiggle trace plot of synthetic wedge model, as above, but now with several
            additional annotations. The true wedge top and base are plotted with thick black lines while the apparent
            wedge top and base are plotted with dashed grey lines. A wiggle trace is also added in thick red at tuning
            thickness and dashed red at onset of tuning thickness.
        </figcaption>
    </figure>
    <p class="text-justify">
        On this version of the synthetic wedge model I've added the true wedge top and base surfaces in thick black
        lines and the apparent wedge top and base surfaces in dashed grey lines. As shown in the above figure of true
        versus apparent wedge thickness, the true and apparent wedge top and base surfaces are the same until the
        onset of tuning thickness. At this wedge thickness, the apparent top and base surfaces diverge from the true
        top and base surfaces and the wedge thickness is actually apparently thinner than true thickness. At tuning
        thickness, the true and apparent surfaces cross and for wedge thickness below tuning thickness, the apparent
        top and base surfaces are now thicker than the true wedge thickness. If the layer we are mapping is below the
        tuning thickness and we pick a trough-peak pair for the top and base surfaces, our interpreted thickness
        will overestimate the true layer thickness.
    </p>
    <p class="text-justify">
        So far I have only discussed the relation between layer thickness and reflection amplitude and how it relates
        to seismic resolution. However, let's turn this discussion on its head and talk about amplitude as a function
        of thickness. It should be very obvious by now (I hope!) that thickness variations impact amplitude around
        tuning thickness. This means that if our layer of interest is close to tuning thickness, any amplitude attribute
        extractions we make will have a tuning component embedded in it. In other words, when beds are thin, amplitudes
        cannot be trusted! If we look at the portion of the tuning curve where thickness is well above tuning, the
        amplitude response is the true amplitude response. At and approaching tuning thickness, amplitude is
        over-estimated as a result of constructive interference. If the layer becomes very thin, the amplitude rapidly
        drops off and becomes significantly below the true amplitude response when the layer is well above tuning. This
        leads us to the topic of <em>Detuning</em> which refers to correcting amplitude maps for tuning thickness
        phenomenon. Detuning is a bit beyond the scope of this discussion so I would instead refer you to the works of
        <a href="https://doi.org/10.1190/1.2794386" target="_blank">Patrick Connolly</a>.
    </p>
    <hr />
    <h1>Seismic Tuning & Spectral Decomposition</h1>
    <p class="text-justify">
        Spectral decomposition in many ways is a very special case of seismic tuning. While there are many different
        ways to implement spectral decomposition, the basic idea is to decompose a seismic trace into narrow frequency
        bands. The <em>Law of Superposition</em> allows us to additively sum narrow frequency band representations of a
        seismic trace to reconstruct the full bandwidth trace. Consider for a moment that in performing spectral
        decomposition of a trace, we create iso-frequency representations of that trace from 5 to 60 Hz in 5 Hz
        increments. If we then compare each of those iso-frequency traces to one another, we will see that for a given
        layer thickness, one of the iso-frequencies will have peak magnitude compared to the others. If that were, for
        example, 25 Hz, then we would say that the event "tunes up" at 25 Hz.
    </p>
    <figure class="figure">
        <img src="../static/img/isofreq_gather.png" class="figure-img img-fluid rounded mx-auto d-block" alt="iso-frequency gather" loading="lazy">
        <figcaption class="figure-caption">
            Panel showing iso-frequency gather response for layers of varying TWT (ms) thickness. As layers increase
            in thickness, the peak magnitude of the iso-frequency gather shifts towards lower frequencies. For each
            layer, the tuning frequency is notated on the gather by a black '+'. The layer thicknesses are 10, 20, 30,
            40, 50, & 100 ms TWT with a 100 ms TWT layer in between, as illustrated in the impedance model. The
            reflectivity series shows the reflection coefficients at the top and base of each layer. Each trace in the
            iso-frequency gather represents the convolution of the reflectivity series with a narrow-band filter which
            in this instance is a Ricker wavelet, displayed as wiggle trace and interpolated density.
        </figcaption>
    </figure>
    <p class="text-justify">
        Tying this back to the seismic tuning wedge model, we know that peak amplitude occurs at the tuning thickness.
        As the frequency used to construct the tuning wedge varies, the tuning thickness varies, as well, but peak
        amplitude is always at the tuning thickness. If we compare the amplitude responses of a given layer at different
        frequencies, we see that one frequency will have peak amplitude compared to all the others. This frequency is
        the tuning frequency and can be used for estimating the layer's thickness. The figure above shows an impedance
        model where each subsequent layer is thicker. We can convolve the reflectivity series derived from this model
        with a suite of Ricker wavelets to create an iso-frequency gather. What we observe is that as layer thickness
        changes, the maximum energy changes as a function of frequency. Thinner layers have maximum energy at higher
        frequencies while thicker layers have maximum energy at lower frequencies. We now know from the tuning wedge
        model that the maximum amplitude at a layer interface occurs at the tuning thickness of the wedge. So, for a
        set layer thickness, the iso-frequency trace with maximum magnitude for that layer is at tuning (hence "tuning
        frequency"), and we can then use the equations above to relate tuning frequency to period and solve for the
        layer's thickness. <em>Spectral Decomposition is really cool!</em>
    </p>
{% endblock %}