{% extends 'base.html' %}
{% block head %}
    {{ super() }}
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
{% endblock %}

{% block content %}
    <h1>{% block title %} About {% endblock %}</h1>
    <p class="text-justify">
        <strong>PySeisTuned<sup>2.0</sup></strong> is a tool for calculating seismic tuning wedges. Input the velocity
        and density properties of the wedge layers, specify the wavelet parameters, and a synthetic tuning wedge and
        tuning curve are generated.
    </p>
    <p class="text-justify">
        The initial release, <strong>PySeisTuned<sup>1.0</sup></strong>, was inspired by Agile Scientific's
        <a href="https://github.com/agile-geoscience/xlines/blob/master/notebooks/00_Synthetic_wedge_model.ipynb"
           target="_blank">"X Lines of Code"</a> Jupyter Notebook series and was written as a standalone GUI using
        Python 3 and PyQT5. In this iteration, a user needs to create a virtual conda environment using the provided
        environment.yml file and then launch the app from a command line prompt. While this works, it probably isn't
        the most user-friendly deployment. PySeisTuned<sup>1.0</sup> is open source and licensed under GPL-3.0 for
        compatibility with PyQT5 licensing.
    </p>
    <div class="container">
        <div class="row row-cols-2">
            <div class="col-sm">
                <img src="../static/img/pst_wedge_calculator.png" class="img-fluid" alt="" loading="lazy">
            </div>
            <div class="col-sm">
                <img src="../static/img/pst_summary_tab.png" class="img-fluid" alt="" loading="lazy">
            </div>
        </div>
    </div><br />
    <p class="text-justify">
        Enter <strong>PySeisTuned<sup>2.0</sup></strong>, which is now a web app! The PyQT5 GUI is gone and now
        PySeisTuned<sup>2.0</sup> runs using Python 3, Flask, HTML5, Bootstrap, & JavaScript. PySeisTuned<sup>2.0</sup>
        is open source and licensed under the Apache-2.0 license. My primary goal in re-writing PySeisTuned<sup>2.0</sup>
        as a web app is to make the tool as easy as possible to use. Web apps have changed the way we interact with software
        and simplifies end-user consumption. To me, this means removing the environmental setup
        steps necessary to run PySeisTuned<sup>1.0</sup> and also removing the need to launch from a terminal. In fact,
        unless you want to clone the repository locally to customize PySeisTuned<sup>2.0</sup>, there is no longer any
        "installation" steps required to get running!
    </p>
    <p class="text-justify">
        Flask is a powerful and easy to use Python-based web app framework that connects the Python code in the
        background with the HTML5 user-interface.  Styling is made simple by utilizing Bootstrap pre-built CSS style
        sheets. Additionally, some custom JavaScript is required to enable features such as a reset button, displaying
        Acoustic Impedance of input layer properties, and displaying the apparent frequency of the specified Ricker
        wavelet. One more enhancement is that all plotting is now done using Bokeh instead of Matplotlib. Using Bokeh
        enables embedding feature-rich, interactive plots that are more appropriate in a web app.
    </p>
    <div class="container">
        <div class="row row-cols-8">
            <div class="col-sm"></div>
            <div class="col-sm">
                <a href="https://www.python.org" target="_blank">
                    <img src="https://img.icons8.com/color/48/000000/python.png" class="img-fluid" alt="" loading="lazy"/>
                </a>
            </div>
            <div class="col-sm">
                <a href="https://docs.bokeh.org/en/latest/index.html#" target="_blank">
                    <img src="../static/img/bokeh-logo.png" width="48" height="48" class="img-fluid" alt="" loading="lazy"/>
                </a>
            </div>
            <div class="col-sm">
                <a href="https://flask.palletsprojects.com/en/1.1.x/" target="_blank">
                    <img src="../static/img/flask-logo.png" width="96" height="96" class="img-fluid" alt="" loading="lazy"/>
                </a>
            </div>
            <div class="col-sm">
                <a href="https://www.w3.org/html/" target="_blank">
                    <img src="https://img.icons8.com/color/48/000000/html-5.png" class="img-fluid" alt="" loading="lazy"/>
                </a>
            </div>
            <div class="col-sm">
                <a href="https://getbootstrap.com/" target="_blank">
                    <img src="https://img.icons8.com/color/48/000000/bootstrap.png" class="img-fluid" alt="" loading="lazy"/>
                </a>
            </div>
            <div class="col-sm">
                <a href="https://www.javascript.com/" target="_blank">
                    <img src="https://img.icons8.com/color/48/000000/javascript.png" class="img-fluid" alt="" loading="lazy"/>
                </a>
            </div>
            <div class="col-sm"></div>
        </div>
    </div>
    <br />
    <p class="text-justify">
        Contributions, suggestions, and bug reports are all welcome! I hope you enjoy using
        <strong>PySeisTuned<sup>2.0</sup></strong> and please let me know if there ways I can make it even better:
    </p>
    <p class="text-justify">
        Follow the links below to view the source code, clone the repository, or submit issues and enhancement requests:
    </p>
    <ul>
        <li>
            <a href="https://github.com/bdowdell/flask_pyseistuned" target="_blank">PySeisTuned<sup>2.0</sup></a>
        </li>
        <li>
            <a href="https://github.com/bdowdell/PySeisTuned" target="_blank">PySeisTuned<sup>1.0</sup></a>
        </li>
    </ul>
    <p class="text-justify">
        You can also send an email directly using the <em>Contact</em> link down below in the footer.
    </p>
    <!-- Introduce a horizontal break to begin a cursory background theory section -->
    <hr />
    <h1>Seismic Tuning Theory Basics</h1>
    <p class="text-justify">
        Seismic Tuning as a concept is a basic geophysical tenet and is crucial in understanding the seismic
        response. The seismic tuning phenomenon arises from constructive interference of reflected waves at layer
        interfaces as the bed thickness between the layer begins to thin. As the bed begins to thin, the reflection from
        the top interface and the bottom interface begin to align and constructively interfere. At a certain point, the
        constructive interference between the two layers will reach a maximum and this is known as the
        <strong>Seismic Tuning Thickness</strong> and is the layer thickness below which the top and base reflections
        are no longer indistinguishable from one another.
    </p>
    <p class="text-justify">
        <a href="https://doi.org/10.1190/1.1440403" target="_blank">Widess (1973)</a>
        published the seminal work on the topic titled <em>"How thin is a thin bed?"</em>, which sought to
        dispel common misconceptions about thin bed resolvability. In the paper, Widess considers two identical wavelets
        offset by a time delay. The two wavelets effectively represent the reflections from the top and base of a layer
        while the time delay effectively represents the bed thickness in Two-Way Time (TWT). Several very important
        definitions arise from Widess's paper:
    </p>
    <dl class="row">
        <dt class="col-sm-3">Onset of Tuning Thickness</dt>
        <dd class="col-sm-9">\(\lambda/2\)</dd>
        <dt class="col-sm-3">Tuning Thickness</dt>
        <dd class="col-sm-9">\(\lambda/4\)</dd>
        <dt class="col-sm-3">Limit of resolution</dt>
        <dd class="col-sm-9">\(\lambda/8\)</dd>
    </dl>
    <p class="text-justify">
        where \(\lambda\) is the velocity-dependent wavelength of the layer's dominant frequency.  Recall the relationship
        between velocity, frequency, and wavelength:
    </p>
    <p>
        $$v = f \times \lambda$$
    </p>
    <p class="text-justify">
        where \(v\) is velocity in (m or ft)/sec, \(f\) is Frequency in Hz (or cycles/sec), and \(\lambda\) is
        wavelength in (m or ft). This equation commonly gets rewritten as:
    </p>
    <p>
        $$\lambda = {v\over f}$$
    </p>
    <p class="text-justify">
        because we typically have an idea about what the velocity and frequency of our zone of interest is and instead
        want to know wavelength. Once we know the dominant frequency wavelength we can then estimate the tuning
        parameters using Widess's definitions above. For example, the tuning thickness is given by:
    </p>
    <p>
        $$\lambda_{tuning} = {v\over f}/4$$
    </p>
    <p class="text-justify">
        We can also define the tuning parameters in terms of TWT thickness.  If we take the inverse of frequency, we
        instead get the TWT period, \(T\) in seconds. The equation above can now be
        written as:
    </p>
    <p>
        $$\lambda = v\times T/2$$
    </p>
    <p class="text-justify">
        with the period \(T\) being divided by two to convert to One-Way Time (OWT).
        Converting the period to OWT is essential as otherwise the depth thickness we measure would be twice the actual
        bed thickness. This means that when the Widess tuning parameters are expressed in terms of TWT, the divisor
        becomes half the wavelength divisor so that when the TWT tuning parameter is converted to OWT, the overall
        relationship remains the same:
    </p>
    <dl class="row">
        <dt class="col-sm-3">Onset of Tuning Thickness</dt>
        <dd class="col-sm-9">\(\lambda/2 = T\)</dd>
        <dt class="col-sm-3">Tuning Thickness</dt>
        <dd class="col-sm-9">\(\lambda/4 = T/2\)</dd>
        <dt class="col-sm-3">Limit of resolution</dt>
        <dd class="col-sm-9">\(\lambda/8 = T/4\)</dd>
    </dl>
    <p class="text-justify">
        such that the tuning parameter thicknesses are given by:
    </p>
    <p>
        \begin{align}
        &\lambda_{onset} = v\times T/2 \\
        &\lambda_{tuning} = v\times (T/2)/2 \\
        &\lambda_{limit} = v\times (T/4)/2
        \end{align}
    </p>
    <p class="text-justify">
        The advantage to expressing the various tuning parameters in TWT versus depth units is that doing so only
        requires knowledge of the layer's dominant frequency and as such, TWT tuning thickness is always constant for
        a given dominant frequency.  In other words, if the dominant frequency of a particular reflection pair is 25 Hz,
        then the TWT tuning thickness is simply:
    </p>
    <p>
        \begin{align}
        T_{tuning} & = 1/f/2 \\
        & = 1/25\;Hz/2 \\
        & = 20\;ms\;TWT\;,
        \end{align}
    </p>
    <p class="text-justify">
        and if we know that the velocity of the layer, either from well log control or a seismic velocity model, is
        3,000 m/s, then the tuning thickness in meters is:
    </p>
    <p>
        \begin{align}
        \lambda_{tuning} & = v\times (T/2)/2 \\
        & = 3000\;m/s\times 20\;ms\;TWT/2 \\
        & = 30\;m
        \end{align}
    </p>
    <hr />
    <h1>Seismic Tuning Wedge Model</h1>
    <p class="text-justify">
        Now that the foundational concepts behind seismic tuning are laid out, we can now understand the utility of
        the <strong>Seismic Tuning Wedge Model</strong>. The seismic tuning wedge model is a simple three-layer forward
        model in which the top and base layers are typically the same and the middle wedge layer simulates the layer of
        interest. In other words, the top and base layers usually represent the encasing shale and the wedge layer
        represents a sandstone. The wedge layer is typically given a maximum thickness well above tuning at one end of
        the model and thins out to zero thickness at the other. The thicknesses of the top and base layers are not
        important as we only care about the reflections generated at the wedge top and base interfaces.
    </p>
    <img src="../static/img/wedge.png" class="img-fluid rounded mx-auto d-block" alt="Wedge Model">
    <br />
    <p class="text-justify">
        For a very simple wedge model, it is only necessary to know the P-velocity and bulk density of the three layers.
        Generally, and as implemented in <strong>PySeisTuned<sup>2.0</sup></strong>,
        the properties of the top and base layers are the same. More detailed forward models can be built to understand
        reflectivity from differing top and base properties, but if the goal is simply to understand seismic resolution
        of a sand body, then in my opinion it is best to keep the top and base properties the same. The underlying
        assumption is that the encasing shales do not have drastically varying properties.
    </p>
    <hr />
    <h1>Seismic Tuning & Spectral Decomposition</h1>
    <p class="text-justify">
        Relationship between spectral decomposition and peak tuning frequency
    </p>
{% endblock %}